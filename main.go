// govcs auto generates vars based on current VCS data.
//
// The current recommended way of doing this is with build flags, but I want to
// commit the information so that `go get` gets the information.
//
// TODOs
// 	* allow to specify a custom template
// 	* add more VC systems
// 	* auto generate flags (if we auto generate flags, do we leave it up to the pkg to parse flags?)
package main

//go:generate govcs

// BUG(bh) you have to commit the file every time, so the version info will
// never match

import (
	"flag"
	"io"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

var tmpl = template.Must(template.New("tmpl").Parse(
	`// auto generated by govcs; DO NOT EDIT

package {{.Package}}

var (
	VCS_TYPE = {{.Type | printf "%#v" }}
	VCS_VERS = {{.Vers | printf "%#v" }}
	VCS_INFO = {{.Info | printf "%#v" }}
)
`))

var (
	packageName = flag.String("package", "main", "package name")
	output      = flag.String("out", "vcs.go", "output file name (- for stdout)")
)

func main() {
	log.SetFlags(0)
	flag.Parse()

	vcs := LookupVCS()

	if vcs == nil {
		log.Fatal("unknown vcs")
	}

	tmpl.Execute(outputFile(), vcs)
}

func outputFile() io.Writer {
	if *output == "-" || *output == "" {
		return os.Stdout
	}

	f, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}

	return f
}

var allVCSFuncs = [...]VCSFunc{
	Git,
}

type VCSFunc func(*VCS) bool

func LookupVCS() *VCS {
	var vcs VCS

	vcs.Package = *packageName

	for _, f := range allVCSFuncs {
		if f(&vcs) {
			return &vcs
		}
	}

	return nil
}

type VCS struct {
	Package string

	Type, Vers, Info string
}

func Git(v *VCS) bool {
	if exec.Command("git", "rev-parse").Run() != nil {
		return false
	}

	v.Type = "git"

	d, _ := exec.Command("git", "rev-parse", "HEAD").Output()
	v.Vers = strings.TrimSpace(string(d))

	d, _ = exec.Command("git", "config", "remote.origin.url").Output()
	v.Info = strings.TrimSpace(string(d))

	return true
}
